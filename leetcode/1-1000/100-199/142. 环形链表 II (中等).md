### 题目描述 TODO:（未完成） 

这是 LeetCode 上的 **[142. 环形链表 II](https://leetcode-cn.com/problems/add-digits/)** ，难度为 **中等**。

Tag : 「链表」、「双指针」

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。




示例 1：
```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

```



提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引

***

### 方法一：双指针

分两步：
1. 判断是否有环
2. 找到链表中的交点

##### 判断链表有环
一个非常简单的思路，通过快、慢指针，快指针一次走两步，慢指针一次走一步，如果链表有环它们总会相遇。

##### 找到链表中的交点


代码：
```Kotin
class Solution {
    /**
     * 模拟
     */
    fun addDigits(num: Int): Int {
        var num = num
        while (num >= 10) {
            num = _addDigits(num)
        }
        return num
    }

    fun _addDigits(num: Int): Int {
        var num = num
        var sum = 0
        while (num > 0) {
            sum += num % 10
            num /= 10
        }
        return sum
    }
}
```
* 时间复杂度：O(logN)
* 空间复杂度：$O(1)

---

### 方法二：数学

树根的定义：
> 例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根。

树根的作用：
1. 数根可以计算模运算的同余，对于非常大的数字的情况下可以节省很多时间。
2. 数字根可作为一种检验计算正确性的方法。例如，两数字的和的数根等于两数字分别的数根的和。
3. 数根也可以用来判断数字的整除性，如果数根能被3或9整除，则原来的数也能被3或9整除。

接下来讨论我们怎么求出树根。

我们把 1 到 30 的树根列出来。

> 原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
>
> 数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3

结合上边的规律，对于给定的 n 有三种情况。

- n 是 0 ，数根就是 0。
- n 不是 9 的倍数，数根就是 n 对 9 取余，即 n mod 9。
- n 是 9 的倍数，数根就是 9。


代码：
```Kotlin
class Solution {
    fun addDigits(num: Int): Int {
        if (num == 0) return 0
        if (num % 9 == 0) return 9

        return num % 9
    }
}
```
我们可以把两种情况统一起来，我们将给定的数字减 1，相当于原数整体向左偏移了 1，然后再将得到的数字对 9 取余，最后将得到的结果加 1 即可。

原数是 n，树根就可以表示成 (n-1) mod 9 + 1。

```aidl
public int addDigits(int num) {
    return (num - 1) % 9 + 1;
}
```


* 时间复杂度：O(1)
* 空间复杂度：O(1)

---

