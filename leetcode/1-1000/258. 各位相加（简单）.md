### 题目描述

这是 LeetCode 上的 **[258. 各位相加](https://leetcode-cn.com/problems/add-digits/)** ，难度为 **简单**。

Tag : 「模拟」、「数学」

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。


示例 1：
```
输入: num = 38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。

```

示例 2：
```
输入: num = 0
输出: 0
```

提示：

0 <= num <= 2^31 - 1


进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

***

### 方法一：模拟

一个直观的做法是根据题意进行模拟，只要 num 位数多于 1 位就可以继续循环。


代码：
```Kotin
class Solution {
    /**
     * 模拟
     */
    fun addDigits(num: Int): Int {
        var num = num
        while (num >= 10) {
            num = _addDigits(num)
        }
        return num
    }

    fun _addDigits(num: Int): Int {
        var num = num
        var sum = 0
        while (num > 0) {
            sum += num % 10
            num /= 10
        }
        return sum
    }
}
```
* 时间复杂度：O(logN)
* 空间复杂度：$O(1)

---

### 方法二：数学

树根的定义：
> 例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根。

树根的作用：
1. 数根可以计算模运算的同余，对于非常大的数字的情况下可以节省很多时间。
2. 数字根可作为一种检验计算正确性的方法。例如，两数字的和的数根等于两数字分别的数根的和。
3. 数根也可以用来判断数字的整除性，如果数根能被3或9整除，则原来的数也能被3或9整除。

接下来讨论我们怎么求出树根。

我们把 1 到 30 的树根列出来。

> 原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
>
> 数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3

结合上边的规律，对于给定的 n 有三种情况。

- n 是 0 ，数根就是 0。
- n 不是 9 的倍数，数根就是 n 对 9 取余，即 n mod 9。
- n 是 9 的倍数，数根就是 9。


代码：
```Kotlin
class Solution {
    fun addDigits(num: Int): Int {
        if (num == 0) return 0
        if (num % 9 == 0) return 9

        return num % 9
    }
}
```
我们可以把两种情况统一起来，我们将给定的数字减 1，相当于原数整体向左偏移了 1，然后再将得到的数字对 9 取余，最后将得到的结果加 1 即可。

原数是 n，树根就可以表示成 (n-1) mod 9 + 1。

```aidl
public int addDigits(int num) {
    return (num - 1) % 9 + 1;
}
```


* 时间复杂度：O(1)
* 空间复杂度：O(1)

---

